<!-- pom.xml -->
<dependency>
    <groupId>org.mock-server</groupId>
    <artifactId>mockserver-junit-jupiter</artifactId>
    <version>5.15.0</version>      <!-- current stable, May 2025 -->
    <scope>test</scope>
</dependency>



package demo;

import static org.mockserver.model.HttpRequest.request;
import static org.mockserver.model.HttpResponse.response;
import static org.mockserver.model.BinaryBody.binary;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import org.mockserver.client.MockServerClient;
import org.mockserver.junit.jupiter.MockServerExtension;
import org.mockserver.junit.jupiter.MockServerSettings;

import javax.net.ssl.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

@ExtendWith(MockServerExtension.class)
/* pin the server to 9443 — MockServer’s “port-unification”
   accepts HTTPS on this port, we restrict the expectation
   itself to secure traffic so plain-HTTP calls 404 */
@MockServerSettings(ports = {9443})
class FileDownloadTest {

    private final MockServerClient mock;          // injected by the extension
    private static final int HTTPS_PORT = 9443;

    FileDownloadTest(MockServerClient client) {   // constructor injection
        this.mock = client;
    }

    @BeforeAll
    static void stubFile(MockServerClient mock) throws Exception {
        mock.when(
                request()
                        .withSecure(true)                 // reject plain HTTP
                        .withMethod("GET")
                        .withPath("/files/report")
        ).respond(
                response()
                        .withStatusCode(200)
                        .withHeader("Content-Type",
                                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
                        .withBody(
                                binary(Files.readAllBytes(
                                        Paths.get("src/test/resources/report.xlsx"))))
        );
    }

    @Test
    void downloadsFile_overHttps() throws Exception {
        SSLContext insecure = trustAllSslContext();       // trust MockServer CA
        HttpClient http = HttpClient.newBuilder()
                                    .sslContext(insecure)
                                    .build();

        HttpRequest req = HttpRequest.newBuilder(
                new URI("https://localhost:" + HTTPS_PORT + "/files/report"))
                .build();

        HttpResponse<byte[]> resp = http.send(
                req, HttpResponse.BodyHandlers.ofByteArray());

        assertEquals(200, resp.statusCode());
        assertTrue(resp.body().length > 0);
    }

    /* helper that turns off certificate + hostname checking */
    private static SSLContext trustAllSslContext() throws Exception {
        TrustManager[] tm = { new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] x, String a) {}
            public void checkServerTrusted(X509Certificate[] x, String a) {}
            public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
        }};
        SSLContext ctx = SSLContext.getInstance("TLS");
        ctx.init(null, tm, new SecureRandom());
        return ctx;
    }
}
